# Process this -*- Autotest -*- file with autom4te.

# Macros for the GNU Bison Test suite.

# Copyright (C) 2003-2015, 2018-2020 Free Software Foundation, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

m4_version_prereq([2.58])


# m4_null_if(VAL, IF-TRUE, IF-FALSE)
# ----------------------------------
# If VAL evaluates to empty or 0, run IF-TRUE, otherwise IF-FALSE.
m4_define([m4_null_if],
[m4_case(m4_quote($1),
         [0], [$2],
         [],  [$2],
         [$3])])


# m4_rpatsubst(STRING, PATTERN, REPLACEMENT)
# ------------------------------------------
# As long as PATTERN matches STRING, replace occurrences of PATTERN by
# REPLACEMENT.
#
# Contrary to m4_bpatsubst, matches PATTERN from previous replacements.
m4_define([m4_rpatsubst],
[m4_if(m4_bregexp([$1], [$2]),
       [-1], [$1],
       [m4_rpatsubst(m4_quote(m4_bpatsubst([$1], [$2], [$3])), [$2], [$3])])])


# AT_SETUP_STRIP(TITLE)
# ---------------------
# Abbreviate the TITLE to be passed to AT_SETUP.  Remove new-lines
# that completely break AT_SETUP.
m4_define([AT_SETUP_STRIP],
[m4_bpatsubsts([$1],
      [%\(language\|skeleton\) "?\([^\" ]*\)"?],
        [\2],
      [%define "?\([-A-Za-z0-9_.]+\)"? \({[^\}]+}\|"[^\"]+"\|[-A-Za-z0-9_.]+\)],
        [\1=\2],
      [%define "?\([-A-Za-z0-9_.]+\)"?],
        [\1],
      [ *
+ *],    [ ])dnl
])


# AT_DATA_NO_FINAL_EOL(FILE, CONTENT)
# -----------------------------------
# Same as AT_DATA, except that CONTENT has no the final end of line.
#
# FIXME: AT_DATA or some variant of AT_DATA may eventually permit
# the final newline to be omitted.  See the threads starting at
# <http://lists.gnu.org/archive/html/bison-patches/2009-07/msg00019.html>.
m4_define([AT_DATA_NO_FINAL_EOL],
[AT_DATA([$1], [$2
])
AT_REQUIRE([
set x `LC_ALL=C ls -l '$1'` &&
  size=$][6 &&
  { test $size -eq 0 || dd obs=1 seek=`expr $size - 1` if=/dev/null of='$1'; }],
  [], [ignore], [ignore])
])



## ------------- ##
## Basic tests.  ##
## ------------- ##


# AT_DIFF_U_CHECK(DIFF-ARGS, EXPECTED-DIFF)
# -----------------------------------------
# If diff -u works as we expect, use it, with headers stripped.
m4_define([AT_DIFF_U_CHECK],
[if $DIFF_U_WORKS; then
  AT_CHECK([diff -u $1 | sed -n '/^@@/,$p' | sed 's/^ $//'], [0], [$2])
fi
])


# AT_PERL_CHECK(PERL-ARGS, ...)
# -----------------------------
# If Perl is available, run this test.
m4_define([AT_PERL_CHECK],
[if test x"$PERL" != x; then
  AT_CHECK(["$PERL" $1], [$2], [$3], [$4])
fi
])


# AT_REQUIRE(CMD, ...)
# --------------------
# Same as AT_CHECK(...) but skip this test if we failed.
m4_define([AT_REQUIRE],
[AT_CHECK([$1 || exit 77], [$2], [$3], [$4])])


# AT_PERL_REQUIRE(PERL-ARGS, ...)
# -------------------------------
# Run this Perl program, or skip the test if Perl is not available.
m4_define([AT_PERL_REQUIRE],
[AT_REQUIRE(["$PERL" $1], [$2], [$3], [$4])])


# AT_MATCHES_CHECK(FILE, PERL-REGEXP, COUNT)
# ------------------------------------------
# Expect COUNT matches of the PERL-REGEXP in FILE.  The file is
# taken in "slurp" mode, i.e., one can match end-of-lines.
m4_define([AT_MATCHES_CHECK],
[AT_PERL_CHECK([-0777 -ne '
    my $count = 0;
    s{$2}{ ++$count; "" }gem;
    printf "$count\n";' $1], [0], [$3
])])


# AT_SAVE_SPECIAL_FILES / AT_RESTORE_SPECIAL_FILES
# ------------------------------------------------
# Don't interfere with caller's files.
m4_divert_text([PREPARE_TESTS],
[at_save_special_files ()
{
  for at_save_file in stderr experr expout
  do
    test ! -f at-bison-check-$at_save_file.bak ||
      as_fn_error 1 "fatal error: back-up on top of a back-up"
    test ! -f $at_save_file || mv $at_save_file at-bison-check-$at_save_file.bak
  done
}

at_restore_special_files ()
{
  for at_save_file in stderr experr expout
  do
    test ! -f at-bison-check-$at_save_file.bak ||
      mv at-bison-check-$at_save_file.bak $at_save_file
  done
}
])

m4_define([AT_SAVE_SPECIAL_FILES],    [at_save_special_files])
m4_define([AT_RESTORE_SPECIAL_FILES], [at_restore_special_files])



## ------------------------------- ##
## Macros decoding Bison options.  ##
## ------------------------------- ##

# AT_LOC_PUSHDEF(FIRST-LINE, FIRST-COLUMN, LAST-LINE, LAST-COLUMN)
# ----------------------------------------------------------------
# Pushdef AT(_LOC)?_(FIRST|LAST)_(LINE|COLUMN).
m4_define([AT_LOC_PUSHDEF],
[m4_pushdef([AT_FIRST_LINE],  [$1])
m4_pushdef([AT_FIRST_COLUMN], [$2])
m4_pushdef([AT_LAST_LINE],    [$3])
m4_pushdef([AT_LAST_COLUMN],  [$4])
m4_pushdef([AT_LOC_FIRST_LINE],   [AT_LOC.AT_FIRST_LINE])
m4_pushdef([AT_LOC_FIRST_COLUMN], [AT_LOC.AT_FIRST_COLUMN])
m4_pushdef([AT_LOC_LAST_LINE],    [AT_LOC.AT_LAST_LINE])
m4_pushdef([AT_LOC_LAST_COLUMN],  [AT_LOC.AT_LAST_COLUMN])])

# AT_LOC_POPDEF
# -------------
# Popdef AT(_LOC)?_(FIRST|LAST)_(LINE|COLUMN).
m4_define([AT_LOC_POPDEF],
[m4_popdef([AT_LOC_FIRST_LINE])
m4_popdef([AT_LOC_FIRST_COLUMN])
m4_popdef([AT_LOC_LAST_LINE])
m4_popdef([AT_LOC_LAST_COLUMN])
m4_popdef([AT_FIRST_LINE])
m4_popdef([AT_FIRST_COLUMN])
m4_popdef([AT_LAST_LINE])
m4_popdef([AT_LAST_COLUMN])
])



# AT_BISON_OPTION_PUSHDEFS([BISON-OPTIONS])
# -----------------------------------------
m4_define([AT_BISON_OPTION_PUSHDEFS],
[m4_divert_text([KILL],
                [_AT_BISON_OPTION_PUSHDEFS($[1], $[2], [$1])])])


# _AT_BISON_OPTION_PUSHDEFS($1, $2, [BISON-OPTIONS])
# --------------------------------------------------
# This macro works around the impossibility to define macros
# inside macros, because issuing '[$1]' is not possible in M4 :(.
# This sucks hard, GNU M4 should really provide M5-like $$1.
m4_define([_AT_BISON_OPTION_PUSHDEFS],
[m4_pushdef([AT_BISON_OPTIONS], [$3])

m4_if([$1$2], $[1]$[2], [],
       [m4_fatal([$0: invalid arguments: $@])])dnl
m4_pushdef([AT_AUTOMOVE_IF],
[m4_bmatch([$3], [%define api\.value\.automove], [$1], [$2])])
m4_pushdef([AT_DEFINES_IF],
[m4_bmatch([$3], [%defines], [$1], [$2])])
m4_pushdef([AT_DEBUG_IF],
           [m4_bmatch([$3], [%debug\|%define parse.trace], [$1], [$2])])
m4_pushdef([AT_ERROR_CUSTOM_IF],
           [m4_bmatch([$3], [%define parse\.error custom], [$1], [$2])])
m4_pushdef([AT_ERROR_DETAILED_IF],
           [m4_bmatch([$3], [%define parse\.error detailed], [$1], [$2])])
m4_pushdef([AT_ERROR_VERBOSE_IF],
           [m4_bmatch([$3], [%define parse\.error verbose], [$1], [$2])])
m4_pushdef([AT_ERROR_SIMPLE_IF],
           [AT_ERROR_CUSTOM_IF([$2], [AT_ERROR_DETAILED_IF([$2], [AT_ERROR_VERBOSE_IF([$2], [$1])], [$1])], [$1])])
m4_pushdef([AT_CXX_IF],
[m4_bmatch([$3], [%language "[Cc]\+\+"\|%skeleton "[a-z0-9]+\.cc"], [$1], [$2])])
m4_pushdef([AT_D_IF],
[m4_bmatch([$3], [%language "[Dd]"\|%skeleton "[a-z0-9]+\.d"], [$1], [$2])])
m4_pushdef([AT_JAVA_IF],
[m4_bmatch([$3], [%language "[Jj][Aa][Vv][Aa]"\|%skeleton "[a-z0-9]+\.java"], [$1], [$2])])
# The target language: "c", "c++", or "java".
m4_pushdef([AT_LANG],
[AT_JAVA_IF([java],
            [AT_CXX_IF([c++],
                       [AT_D_IF([d],
                                [c])])])])
m4_pushdef([AT_C_IF],
[m4_if(AT_LANG, [c], [$1], [$2])])
m4_pushdef([AT_GLR_IF],
[m4_bmatch([$3], [%glr-parser\|%skeleton "glr\..*"], [$1], [$2])])
m4_pushdef([AT_LALR1_CC_IF],
[AT_CXX_IF([AT_GLR_IF([$2], [$1])], [$2])])
m4_pushdef([AT_GLR_CC_IF],
[AT_CXX_IF([AT_GLR_IF([$1], [$2])], [$2])])
# Using yacc.c?
m4_pushdef([AT_YACC_IF],
[m4_bmatch([$3], [%language\|%glr-parser\|%skeleton], [$2], [$1])])
m4_pushdef([AT_LAC_IF],
[m4_bmatch([$3], [%define parse.lac full], [$1], [$2])])
m4_pushdef([AT_LEXPARAM_IF],
[m4_bmatch([$3], [%lex-param], [$1], [$2])])
m4_pushdef([AT_LOCATION_IF],
[m4_bmatch([$3], [%locations], [$1], [$2])])
# Whether we use the Span location type (see calc.at), whose members are
# not named like those of the default location type (on purpose, to make
# sure we can use a user type).
m4_pushdef([AT_LOCATION_TYPE_SPAN_IF],
[m4_bmatch([$3], [%define \(api\.location\.type\|location_type\) \{Span\}], [$1], [$2])])
m4_pushdef([AT_PARAM_IF],
[m4_bmatch([$3], [%parse-param], [$1], [$2])])

# Comma-terminated list of formals parse-parameters.
# E.g., %parse-param { int x } %parse-param {int y} -> "int x, int y, ".
m4_bpatsubst([$3], [%parse-param { *\([^{}]*[^{} ]\) *}{ *\([^{}]*[^{} ]\) *}{ *\([^{}]*[^{} ]\) *}],
             [m4_append([AT_PARSE_PARAMS], [\1, \2, \3], [, ])])
m4_bpatsubst([$3], [%parse-param { *\([^{}]*[^{} ]\) *}{ *\([^{}]*[^{} ]\) *}\([^{].*\)?$],
             [m4_append([AT_PARSE_PARAMS], [\1, \2], [, ])])
m4_rpatsubst([$3], [%parse-param { *\([^{}]*[^{} ]\) *}\([^{}].*\)?$],
             [m4_append([AT_PARSE_PARAMS], [\1], [, ])\2])
m4_ifndef([AT_PARSE_PARAMS],
          [m4_define([AT_PARSE_PARAMS])])

m4_pushdef([AT_PARSER_CLASS],
[m4_bmatch([$3], [%define  *api\.parser\.class {\([^\}]*\)}],
           [m4_bregexp([$3], [%define  *api\.parser\.class {\([^\}]*\)}], [\1])],
           [AT_API_PREFIX[]Parser])])

m4_pushdef([AT_PURE_IF],
[m4_bmatch([$3], [%define  *api\.pure\|%pure-parser],
           [m4_bmatch([$3], [%define  *api\.pure *false], [$2], [$1])],
           [$2])])
m4_pushdef([AT_PUSH_IF],
[m4_bmatch([$3], [%define api.push-pull \(both\|pull\)], [$1], [$2])])
# AT_NAME_PREFIX.
m4_pushdef([AT_NAME_PREFIX],
[m4_bmatch([$3], [\(%define api\.prefix\|%name-prefix\) .*],
   [m4_bregexp([$3],
     [\(%define api\.prefix\|%name-prefix\) [\{\"]\([^\"\}]*\)[\"\}]],
     [\2])],
   [AT_JAVA_IF([YY], [yy])])])
# AT_NAMESPACE: also consider api.prefix.  FIXME: Stop that confusion.
m4_pushdef([AT_NAMESPACE],
[m4_bmatch([$3], [\(%define api\.\(namespace\|prefix\)\|%name-prefix\) .*],
   [m4_bregexp([$3],
     [\(%define api\.\(namespace\|prefix\)\|%name-prefix\) [\{\"]\([^\"\}]*\)[\"\}]],
     [\3])],
   [yy])])
m4_pushdef([AT_TOKEN_CTOR_IF],
[m4_bmatch([$3], [%define api\.token\.constructor], [$1], [$2])])
m4_pushdef([AT_TOKEN_PREFIX],
[m4_bmatch([$3], [%define api\.token\.prefix {.*}],
           [m4_bregexp([$3], [%define api\.token\.prefix {\(.*\)}], [\1])])])
m4_pushdef([AT_TOKEN_RAW_IF],
[m4_bmatch([$3], [%define api\.token\.raw], [$1], [$2])])
m4_pushdef([AT_VARIANT_IF],
[m4_bmatch([$3], [%define api\.value\.type variant], [$1], [$2])])
m4_pushdef([AT_API_prefix],
[m4_bmatch([$3], [%define api\.prefix {.*}],
           [m4_bregexp([$3], [%define api\.prefix {\([^\}]*\)}], [\1])],
           [AT_JAVA_IF([YY], [yy])])])
m4_pushdef([AT_API_PREFIX],
[m4_toupper(AT_API_prefix)])
# yyerror receives the location if %location, and if the parser is pure. For
# historical reasons, with the "yacc.c" skeleton, the location is not passed
# unless an additional "%parse-param" is present, or if the purity is defined
# as "full".
m4_pushdef([AT_YYERROR_ARG_LOC_IF],
[AT_LOCATION_IF([AT_PURE_IF([m4_bmatch([$3],
                                       m4_quote(m4_join([\|],
                                                        [%define api\.pure full],
                                                        [%glr-parser],
                                                        [%parse-param],
                                                        [%skeleton "?glr.c"?])),
                                       [$1], [$2])],
                            [$2])],
                    [$2])])

# yyerror always sees the locations (when activated) if the parser is impure.
# When the parser is pure, yyerror sees the location if it is received as an
# argument.
m4_pushdef([AT_YYERROR_SEES_LOC_IF],
[AT_LOCATION_IF([AT_YACC_IF([AT_PURE_IF([AT_YYERROR_ARG_LOC_IF([$1], [$2])],
                                        [$1])],
                            [$1])],
                [$2])])

# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.
m4_pushdef([AT_PURE_LEX_IF],
[AT_PURE_IF([$1],
            [AT_CXX_IF([$1], [$2])])])

m4_pushdef([AT_YYSTYPE],
[AT_CXX_IF([AT_NAMESPACE[::parser::semantic_type]],
               [AT_API_PREFIX[STYPE]])])
m4_pushdef([AT_YYLTYPE],
[AT_CXX_IF([AT_NAMESPACE[::parser::location_type]],
               [AT_API_PREFIX[LTYPE]])])

AT_TOKEN_CTOR_IF(
[m4_pushdef([AT_LOC], [[(]AT_NAME_PREFIX[lloc)]])
 m4_pushdef([AT_VAL], [[(]AT_NAME_PREFIX[lval)]])
 m4_pushdef([AT_YYLEX_FORMALS],     [])
 m4_pushdef([AT_YYLEX_RETURN],      [yy::parser::symbol_type])
 m4_pushdef([AT_YYLEX_ARGS],        [])
 m4_pushdef([AT_USE_LEX_ARGS],      [])
 m4_pushdef([AT_YYLEX_PRE_FORMALS], [])
 m4_pushdef([AT_YYLEX_PRE_ARGS],    [])],
[AT_PURE_LEX_IF(
[m4_pushdef([AT_LOC], [(*llocp)])
 m4_pushdef([AT_VAL], [(*lvalp)])
 m4_pushdef([AT_YYLEX_FORMALS],
            [AT_YYSTYPE *lvalp[]AT_LOCATION_IF([, AT_YYLTYPE *llocp])])
 m4_pushdef([AT_YYLEX_RETURN], [int])
 m4_pushdef([AT_YYLEX_ARGS],
            [lvalp[]AT_LOCATION_IF([, llocp])])
 m4_pushdef([AT_USE_LEX_ARGS],
            [(void) lvalp;AT_LOCATION_IF([(void) llocp;])])
 m4_pushdef([AT_YYLEX_PRE_FORMALS],
            [AT_YYLEX_FORMALS, ])
 m4_pushdef([AT_YYLEX_PRE_ARGS],
            [AT_YYLEX_ARGS, ])
],
[m4_pushdef([AT_LOC], [[(]AT_NAME_PREFIX[lloc)]])
 m4_pushdef([AT_VAL], [[(]AT_NAME_PREFIX[lval)]])
 m4_pushdef([AT_YYLEX_FORMALS],     [void])
 m4_pushdef([AT_YYLEX_RETURN],      [int])
 m4_pushdef([AT_YYLEX_ARGS],        [])
 m4_pushdef([AT_USE_LEX_ARGS],      [])
 m4_pushdef([AT_YYLEX_PRE_FORMALS], [])
 m4_pushdef([AT_YYLEX_PRE_ARGS],    [])
])])


# Handle the different types of location components.
AT_LOCATION_TYPE_SPAN_IF(
    [AT_LOC_PUSHDEF([first.l], [first.c], [last.l], [last.c])],
    [AT_CXX_IF([AT_LOC_PUSHDEF([begin.line], [begin.column], [end.line], [end.column])],
               [AT_LOC_PUSHDEF([first_line], [first_column], [last_line], [last_column])])])


AT_GLR_IF([AT_KEYWORDS([glr])])
])# _AT_BISON_OPTION_PUSHDEFS


# AT_BISON_OPTION_POPDEFS
# -----------------------
m4_define([AT_BISON_OPTION_POPDEFS],
[m4_divert_text([KILL],
[m4_popdef([AT_BISON_OPTIONS])

m4_popdef([AT_YYLEX_PRE_ARGS])
m4_popdef([AT_YYLEX_PRE_FORMALS])
m4_popdef([AT_USE_LEX_ARGS])
m4_popdef([AT_YYLEX_ARGS])
m4_popdef([AT_YYLEX_FORMALS])
m4_popdef([AT_YYLTYPE])
m4_popdef([AT_YYSTYPE])
m4_popdef([AT_VAL])
m4_popdef([AT_LOC])
m4_popdef([AT_PURE_LEX_IF])
m4_popdef([AT_YYERROR_SEES_LOC_IF])
m4_popdef([AT_YYERROR_ARG_LOC_IF])
m4_popdef([AT_API_PREFIX])
m4_popdef([AT_API_prefix])
m4_popdef([AT_VARIANT_IF])
m4_popdef([AT_TOKEN_RAW_IF])
m4_popdef([AT_TOKEN_PREFIX])
m4_popdef([AT_TOKEN_CTOR_IF])
m4_popdef([AT_NAMESPACE])
m4_popdef([AT_NAME_PREFIX])
m4_popdef([AT_LOCATION_TYPE_SPAN_IF])
m4_popdef([AT_LOCATION_IF])
m4_undefine([AT_PARSE_PARAMS])
m4_popdef([AT_PUSH_IF])
m4_popdef([AT_PURE_IF])
m4_popdef([AT_PARSER_CLASS])
m4_popdef([AT_PARAM_IF])
m4_popdef([AT_LEXPARAM_IF])
m4_popdef([AT_LAC_IF])
m4_popdef([AT_YACC_IF])
m4_popdef([AT_GLR_IF])
m4_popdef([AT_CXX_IF])
m4_popdef([AT_C_IF])
m4_popdef([AT_LANG])
m4_popdef([AT_JAVA_IF])
m4_popdef([AT_GLR_CC_IF])
m4_popdef([AT_LALR1_CC_IF])
m4_popdef([AT_ERROR_SIMPLE_IF])
m4_popdef([AT_ERROR_VERBOSE_IF])
m4_popdef([AT_ERROR_DETAILED_IF])
m4_popdef([AT_ERROR_CUSTOM_IF])
m4_popdef([AT_DEBUG_IF])
m4_popdef([AT_DEFINES_IF])
m4_popdef([AT_AUTOMOVE_IF])
AT_LOC_POPDEF])dnl
])# AT_BISON_OPTION_POPDEFS



## -------------------------- ##
## Generating Grammar Files.  ##
## -------------------------- ##

# AT_LANG_CASE(LANG1, IF-LANG1, LANG2, IF-LANG2, ..., DEFAULT)
# ------------------------------------------------------------
m4_define([AT_LANG_CASE],
[m4_case(AT_LANG, $@)])


# AT_LANG_MATCH(LANG1, IF-LANG1, LANG2, IF-LANG2, ..., DEFAULT)
# ------------------------------------------------------------
m4_define([AT_LANG_MATCH],
[m4_bmatch(AT_LANG, $@)])


# _AT_LANG_DISPATCH(LANG, MACRO, ARGS)
# ------------------------------------
# Call the specialization of MACRO for LANG with ARGS.  Complain if
# unavailable.
m4_define([_AT_LANG_DISPATCH],
[m4_ifdef([$2($1)],
       [m4_indir([$2($1)], m4_shift2($@))],
       [m4_fatal([$2: unknown language: $1])])])


# AT_LANG_DISPATCH(MACRO, ARGS)
# -----------------------------
# Call the specialization of MACRO for AT_LANG with ARGS.  Complain if
# unavailable.
m4_define([AT_LANG_DISPATCH],
[_AT_LANG_DISPATCH(AT_LANG, $@)])



# AT_DATA_SOURCE_PROLOGUE
# -----------------------
# The prologue that should be included in any source code that is
# meant to be compiled.  Keep atlocal.in sync (BISON_CXX_WORKS).
m4_define([AT_DATA_SOURCE_PROLOGUE],
[[/* Adjust to the compiler.
  We used to do it here, but each time we add a new line,
  we have to adjust all the line numbers in error messages.
  It's simpler to use a constant include to a varying file.  */
#include <testsuite.h>
]])

# AT_DATA_GRAMMAR_PROLOGUE
# ------------------------
# The prologue that should be included in any grammar whose parser is
# meant to be compiled.
m4_define([AT_DATA_GRAMMAR_PROLOGUE],
[[%code top { /* -*- ]AT_LANG[ -*- */
]AT_DATA_SOURCE_PROLOGUE[]dnl
[}
]])

# AT_DATA_SOURCE(NAME, CONTENT)
# -----------------------------
# Generate the file NAME, whose CONTENT is preceded by
# AT_DATA_SOURCE_PROLOGUE.
m4_define([AT_DATA_SOURCE],
[AT_DATA([$1],
[AT_DATA_SOURCE_PROLOGUE
$2])
])


# AT_DATA_GRAMMAR(NAME, CONTENT)
# ------------------------------
# Generate the file NAME, whose CONTENT is preceded by
# AT_DATA_GRAMMAR_PROLOGUE.
m4_define([AT_DATA_GRAMMAR], [AT_LANG_DISPATCH([$0], $@)])


# AT_YYLEX_PROTOTYPE
# AT_YYLEX_DECLARE_EXTERN
# AT_YYLEX_DECLARE
# AT_YYLEX_DEFINE([INPUT], [ACTION])
# ----------------------------------
# INPUT can be empty, or in double quotes, or a list (in braces).
# ACTION may compute yylval for instance, using "res" as token kind,
# and "toknum" as the number of calls to yylex (starting at 0).
m4_define([AT_YYLEX_PROTOTYPE],
[AT_YYLEX_RETURN AT_NAME_PREFIX[]lex (]AT_YYLEX_FORMALS[)[]dnl
])

m4_define([AT_YYLEX_DECLARE_EXTERN],
[AT_YYLEX_PROTOTYPE;dnl
])

m4_define([AT_YYLEX_DECLARE],
[static AT_YYLEX_DECLARE_EXTERN[]dnl
])


# AT_YYLEX_DEFINE([INPUT], [ACTION])
m4_define([AT_YYLEX_DEFINE],  [AT_LANG_DISPATCH([$0], $@)])


# AT_YYERROR_FORMALS
# AT_YYERROR_PROTOTYPE
# AT_YYERROR_DECLARE_EXTERN
# AT_YYERROR_DECLARE
# AT_YYERROR_DEFINE
# -------------------------
# Must be called inside a AT_BISON_OPTION_PUSHDEFS/POPDEFS pair.
m4_define([AT_YYERROR_FORMALS],  [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_YYERROR_PROTOTYPE],[AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_YYERROR_DECLARE_EXTERN], [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_YYERROR_DECLARE],  [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_YYERROR_DEFINE],   [AT_LANG_DISPATCH([$0], $@)])

# AT_MAIN_DEFINE
# --------------
m4_define([AT_MAIN_DEFINE],   [AT_LANG_DISPATCH([$0], $@)])



## --- ##
## C.  ##
## --- ##

# AT_DATA_GRAMMAR(c)(NAME, CONTENT)
# ---------------------------------
# Generate the file NAME, with CONTENT.
m4_define([AT_DATA_GRAMMAR(c)],
[AT_DATA([$1],
[AT_DATA_GRAMMAR_PROLOGUE
$2])
])

m4_define([AT_YYERROR_FORMALS(c)],
[AT_YYERROR_ARG_LOC_IF([AT_YYLTYPE const * const llocp, ])AT_PARAM_IF([AT_PARSE_PARAMS, ])[const char *msg]])

m4_define([AT_YYERROR_PROTOTYPE(c)],
[[void ]AT_NAME_PREFIX[error (]AT_YYERROR_FORMALS[)]])

m4_define([AT_YYERROR_DECLARE_EXTERN(c)],
[AT_YYERROR_PROTOTYPE;])

m4_define([AT_YYERROR_DECLARE(c)],
[[#include <stdio.h>
]AT_LOCATION_IF([[
#if defined ]AT_YYLTYPE[_IS_TRIVIAL && ]AT_YYLTYPE[_IS_TRIVIAL
static int location_print (FILE *yyo, ]AT_YYLTYPE[ const * const yylocp);
# ifndef LOCATION_PRINT
#  define LOCATION_PRINT(File, Loc) location_print (File, &(Loc))
# endif
#endif
]])[
static ]AT_YYERROR_DECLARE_EXTERN])


# "%define parse.error custom" uses a different format, easy to check.
# The "verbose" one can be computed from it (see _AT_CHECK_CALC_ERROR).
m4_define([AT_YYERROR_DEFINE(c)],
[AT_LOCATION_IF([[
# if defined ]AT_YYLTYPE[_IS_TRIVIAL && ]AT_YYLTYPE[_IS_TRIVIAL
/* Print *YYLOCP on YYO. */
__attribute__((__unused__))
static int
location_print (FILE *yyo, ]AT_YYLTYPE[ const * const yylocp)
{
  int res = 0;
  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
  if (0 <= yylocp->first_line)
    {
      res += fprintf (yyo, "%d", yylocp->first_line);
      if (0 <= yylocp->first_column)
        res += fprintf (yyo, ".%d", yylocp->first_column);
    }
  if (0 <= yylocp->last_line)
    {
      if (yylocp->first_line < yylocp->last_line)
        {
          res += fprintf (yyo, "-%d", yylocp->last_line);
          if (0 <= end_col)
            res += fprintf (yyo, ".%d", end_col);
        }
      else if (0 <= end_col && yylocp->first_column < end_col)
        res += fprintf (yyo, "-%d", end_col);
    }
  return res;
}
#endif
]])[

]AT_ERROR_CUSTOM_IF([[
int
yyreport_syntax_error (const yypcontext_t *ctx]AT_PARAM_IF([, AT_PARSE_PARAMS])[)
{
  int res = 0;]AT_PARAM_IF([m4_bpatsubst(m4_defn([AT_PARSE_PARAMS]),
              [[^,]+[^A-Za-z_0-9]\([A-Za-z_][A-Za-z_0-9]*\),* *], [
  YYUSE (\1);])])[]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs],[[
  ++global_nerrs;
  ++*nerrs;]])[]AT_LOCATION_IF([[
  LOCATION_PRINT (stderr, *yypcontext_location (ctx));
  fprintf (stderr, ": ");]])[
  fprintf (stderr, "syntax error");
  {
    yysymbol_kind_t la = yypcontext_token (ctx);
    if (la != YYSYMBOL_YYEMPTY)
      fprintf (stderr, " on token [%s]", yysymbol_name (la));
  }
  {
    enum { TOKENMAX = 10 };
    yysymbol_kind_t expected[TOKENMAX];
    int n = yypcontext_expected_tokens (ctx, expected, TOKENMAX);
    /* Forward errors to yyparse.  */
    if (n <= 0)
      res = n;
    else
      {
        fprintf (stderr, " (expected:");
        for (int i = 0; i < n; ++i)
          fprintf (stderr, " [%s]", yysymbol_name (expected[i]));
        fprintf (stderr, ")");
      }
  }
  fprintf (stderr, "\n");
  return res;
}
]])[

/* A C error reporting function.  */
static
]AT_YYERROR_PROTOTYPE[
{]m4_bpatsubst(m4_defn([AT_PARSE_PARAMS]),
              [[^,]+[^A-Za-z_0-9]\([A-Za-z_][A-Za-z_0-9]*\),* *], [
  YYUSE (\1);])dnl
AT_YYERROR_SEES_LOC_IF([[
  LOCATION_PRINT (stderr, ]AT_LOC[);
  fprintf (stderr, ": ");]])[
  fprintf (stderr, "%s\n", msg);]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs],[[
  ++global_nerrs;
  ++*nerrs;]])[
}]])])


m4_define([AT_YYLEX_DEFINE(c)],
[[#include <assert.h>
static
]AT_YYLEX_PROTOTYPE[
{
  ]m4_bmatch([$1], [^\(".*"\)?$],
             [[static char const input[] = ]m4_default([$1], [""])],
             [[static int const input[] = ]$1])[;
  static int toknum = 0;
  int res;
  ]AT_USE_LEX_ARGS[
  enum { input_elts = sizeof input / sizeof input[0] };
  (void) input_elts;
  assert (0 <= toknum && toknum < input_elts);
  res = input[toknum++];
  ]$2[;]AT_TOKEN_CTOR_IF([], [[
  ]AT_LOCATION_IF([[
  ]AT_LOC_FIRST_LINE[ = ]AT_LOC_LAST_LINE[ = 1;
  ]AT_LOC_FIRST_COLUMN[ = ]AT_LOC_LAST_COLUMN[ = toknum;]])[
  return res;]])[
}]])


m4_define([AT_MAIN_DEFINE(c)],
[[#include <stdlib.h> /* getenv. */
#include <string.h> /* strcmp. */
int
main (int argc, char const* argv[])
{]AT_DEBUG_IF([[
  yydebug = !!getenv ("YYDEBUG");
  for (int i = 1; i < argc; ++i)
    if (!strcmp (argv[i], "-p")
        || !strcmp (argv[i], "-d") || !strcmp (argv[i], "--debug"))
      yydebug |= 1;
    else if (!strcmp (argv[i], "-s") || !strcmp (argv[i], "--stat"))
      yydebug |= 2;]], [[
  (void) argc;
  (void) argv;]])[
  return ]AT_NAME_PREFIX[parse ();
}]])

m4_define([AT_LANG_FOR_EACH_STD(c)],
[$1])


## ----- ##
## C++.  ##
## ----- ##


# AT_DATA_GRAMMAR(NAME, CONTENT)
# ------------------------------
m4_copy([AT_DATA_GRAMMAR(c)], [AT_DATA_GRAMMAR(c++)])

# No need to declare, it's part of the class interface.
m4_define([AT_YYERROR_DECLARE(c++)],        [])
m4_define([AT_YYERROR_DECLARE_EXTERN(c++)], [])

m4_define([AT_YYERROR_DEFINE(c++)],
[[/* A C++ error reporting function.  */
void
]AT_NAMESPACE[::parser::error (]AT_LOCATION_IF([[const location_type& l, ]])[const std::string& m)
{]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs],[[
  ++global_nerrs;
  ++*nerrs;]])[
  std::cerr << ]AT_LOCATION_IF([l << ": " << ])[m << '\n';
}]AT_ERROR_CUSTOM_IF([[
void
]AT_NAMESPACE[::parser::report_syntax_error (const context& ctx) const
{]AT_PARAM_IF([m4_bpatsubst(m4_defn([AT_PARSE_PARAMS]),
              [[^,]+[^A-Za-z_0-9]\([A-Za-z_][A-Za-z_0-9]*\),* *], [
  YYUSE (\1);])])[]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs],[[
  ++global_nerrs;
  ++*nerrs;]])[]AT_LOCATION_IF([[
  std::cerr << ctx.location () << ": ";]])[
  std::cerr << "syntax error";
  {
    symbol_kind_type la = ctx.token ();
    if (la != symbol_kind::S_YYEMPTY)
      std::cerr << " on token [" << symbol_name (la) << ']';
  }
  {
    enum { TOKENMAX = 10 };
    symbol_kind_type expected[TOKENMAX];
    int n = ctx.expected_tokens (expected, TOKENMAX);
    if (0 < n)
      {
        std::cerr << " (expected:";
        for (int i = 0; i < n; ++i)
          std::cerr << " [" << symbol_name (expected[i]) << ']';
        std::cerr << ')';
      }
  }
  std::cerr << '\n';
}]])])


# AT_YYLEX_DEFINE(c++)([INPUT], [ACTION])
# ---------------------------------------
# Same as in C.
m4_copy([AT_YYLEX_DEFINE(c)], [AT_YYLEX_DEFINE(c++)])


m4_define([AT_MAIN_DEFINE(c++)],
[[#include <cstdlib> // getenv.
#include <cstring> // strcmp.
int
main (int argc, char const* argv[])
{
  ]AT_NAMESPACE[::parser p;]AT_DEBUG_IF([[
  int debug = !!getenv ("YYDEBUG");
  for (int i = 1; i < argc; ++i)
    if (!strcmp (argv[i], "-p")
        || !strcmp (argv[i], "-d") || !strcmp (argv[i], "--debug"))
      debug |= 1;
    else if (!strcmp (argv[i], "-s") || !strcmp (argv[i], "--stat"))
      debug |= 2;
  p.set_debug_level (debug);]], [[
  (void) argc;
  (void) argv;]])[
  return p.parse ();
}]])

m4_define([AT_LANG_FOR_EACH_STD(c++)],
[AT_FOR_EACH_CXX([$1])])

m4_define([AT_FOR_EACH_CXX],
[[at_for_each_std_CXXFLAGS_save=$CXXFLAGS
for at_std in '' \
              ${CXX98_CXXFLAGS:+"$CXX98_CXXFLAGS"} \
              ${CXX03_CXXFLAGS:+"$CXX03_CXXFLAGS"} \
              ${CXX11_CXXFLAGS:+"$CXX11_CXXFLAGS"} \
              ${CXX14_CXXFLAGS:+"$CXX14_CXXFLAGS"} \
              ${CXX17_CXXFLAGS:+"$CXX17_CXXFLAGS"} \
              ${CXX2A_CXXFLAGS:+"$CXX2A_CXXFLAGS"}
do
  ]AS_ECHO(["======== Testing with C++ standard flags: '$at_cxx_std'"])[
  CXXFLAGS="$at_for_each_std_CXXFLAGS_save $at_std"
  ]$1[
done
CXXFLAGS=$at_for_each_std_CXXFLAGS_save
]])



## --- ##
## D.  ##
## --- ##

# AT_DATA_GRAMMAR(NAME, CONTENT)
# ------------------------------
m4_copy([AT_DATA], [AT_DATA_GRAMMAR(d)])


# No need to declare, it's part of the class interface.
m4_define([AT_YYERROR_DECLARE(d)],        [])
m4_define([AT_YYERROR_DECLARE_EXTERN(d)], [])

m4_define([AT_YYERROR_DEFINE(d)],
[[/* An error reporting function.  */
public void yyerror (]AT_LOCATION_IF([[YYLocation l, ]])[string m)
{
  stderr.writeln (]AT_LOCATION_IF([[l, ": ", ]])[m);
}]])


m4_define([AT_MAIN_DEFINE(d)],
[[int main ()
{
  auto l = new ]AT_API_prefix[Lexer ();
  auto p = new ]AT_API_PREFIX[Parser (l);
  return p.parse ();
}]])



## ------ ##
## Java.  ##
## ------ ##


# AT_DATA_GRAMMAR(NAME, CONTENT)
# ------------------------------
m4_copy([AT_DATA], [AT_DATA_GRAMMAR(java)])

# No need to declare, it's part of the class interface.
m4_define([AT_YYERROR_DECLARE(java)],        [])
m4_define([AT_YYERROR_DECLARE_EXTERN(java)], [])

# AT_JAVA_POSITION_DEFINE
# -----------------------
m4_define([AT_JAVA_POSITION_DEFINE],
[[class Position {
  public int line = 1;
  public int column = 1;

  public Position ()
  {
    line = 1;
    column = 1;
  }

  public Position (int l, int t)
  {
    line = l;
    column = t;
  }

  public Position (Position p)
  {
    line = p.line;
    column = p.column;
  }

  public void set (Position p)
  {
    line = p.line;
    column = p.column;
  }

  public boolean equals (Position l)
  {
    return l.line == line && l.column == column;
  }

  public String toString ()
  {
    return Integer.toString (line) + "." + Integer.toString (column);
  }

  public int line ()
  {
    return line;
  }

  public int column ()
  {
    return column;
  }
}

class PositionReader extends BufferedReader {

  private Position position = new Position ();
  private Position previousPosition = new Position ();

  public PositionReader (Reader reader) {
    super (reader);
  }

  public int read () throws IOException {
    int res = super.read ();
    previousPosition.set (position);
    if (res > -1) {
      char c = (char)res;
      if (c == '\r' || c == '\n') {
        position.line += 1;
        position.column = 1;
      } else {
        position.column += 1;
      }
    }
    return res;
  }

  public Position getPosition () {
    return position;
  }

  public Position getPreviousPosition () {
    return previousPosition;
  }
}]])


# AT_YYERROR_DEFINE(java)
# -----------------------
# FIXME: We should not hard-code "Calc".
m4_define([AT_YYERROR_DEFINE(java)],
[AT_LOCATION_IF([[public void yyerror (Calc.Location l, String m)
  {]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs], [[
    ++global_nerrs;
    ++*nerrs;]])[
    if (l == null)
      System.err.println(m);
    else
      System.err.println(l + ": " + m);
  }
]], [[
  public void yyerror (String m)
  {]m4_bmatch(m4_defn([AT_PARSE_PARAMS]), [nerrs],[[
    ++global_nerrs;
    ++*nerrs;]])[
    System.err.println (m);
  }
]])[

]AT_ERROR_CUSTOM_IF([[
  public void reportSyntaxError(Calc.Context ctx) {
    System.err.print(]AT_LOCATION_IF([[ctx.getLocation() + ": "
                     + ]])["syntax error");
    {
      Calc.SymbolKind token = ctx.getToken();
      if (token != null)
        System.err.print(" on token @<:@" + token.getName() + "@:>@");
    }
    {
      Calc.SymbolKind[] arg = new Calc.SymbolKind[ctx.NTOKENS];
      int n = ctx.getExpectedTokens(arg, ctx.NTOKENS);
      if (0 < n) {
        System.err.print(" (expected:");
        for (int i = 0; i < n; ++i)
          System.err.print(" @<:@" + arg[i].getName() + "@:>@");
        System.err.print(")");
      }
    }
    System.err.println("");
  }
]])
])

m4_define([AT_YYLEX_DEFINE(java)],
[[
  /*--------.
  | yylex.  |
  `--------*/

  public String input = "]$1[";
  public int index = 0;
  public int yylex ()
  {
    if (index < input.length ())
      return input.charAt (index++);
    else
      return 0;
  }
  public Object getLVal ()
  {
    ]$2[;
  }
]])

m4_define([AT_MAIN_DEFINE(java)],
[[class input
{
  public static void main (String[] args) throws IOException
  {
    ]AT_API_prefix[Parser p = new ]AT_API_prefix[Parser ();
    boolean success = p.parse ();
    if (!success)
      System.exit (1);
  }
}]])

m4_define([AT_LANG_FOR_EACH_STD(java)],
[$1])



## --------------- ##
## Running Bison.  ##
## --------------- ##

# AT_BISON_CHECK(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# -------------------------------------------------
# High-level routine that may call bison several times, under different
# conditions.
#
# Check Bison by invoking 'bison BISON_ARGS'.  BISON_ARGS should not contain
# shell constructs (such as redirection or pipes) that would prevent
# appending additional command-line arguments for bison. OTHER_AT_CHECK_ARGS
# are the usual remaining arguments to AT_CHECK: STATUS, STDOUT, etc.
#
# This macro or AT_BISON_CHECK_NO_XML should always be used whenever invoking
# Bison in the test suite.  For now it ensures that:
#
#   1. Valgrind doesn't report reachable memory when Bison is expected to have
#      a non-zero exit status since Bison doesn't always try to free all memory
#      in that case.
#
#   2. In the case of maintainer-xml-check, XML/XSLT output is compared with
#      --graph and --report=all output for every working grammar.
#
#   3. If stderr contains a warning, -Werror and --warnings=error
#      convert the warning to an error.
#
#   4. If stderr contains a warning, -Wnone and --warnings=none suppress it.
m4_define([AT_BISON_CHECK],
[m4_null_if([$2], [AT_BISON_CHECK_XML($@)])
AT_BISON_CHECK_NO_XML($@)])

# AT_BISON_CHECK_(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# --------------------------------------------------
# Low-level macro to run bison once.
m4_define([AT_BISON_CHECK_],
[AT_CHECK(AT_SET_ENV[[ bison --color=no -fno-caret ]]$@)])


# AT_BISON_CHECK_WARNINGS(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# ----------------------------------------------------------
# Check that warnings (if some are expected) are correctly
# turned into errors with -Werror, etc.
#
# When -Wno-error is used, the rules are really different, don't try.
m4_define([AT_BISON_CHECK_WARNINGS],
[m4_if(m4_bregexp([$4], [: warning: ]), [-1], [],
       m4_bregexp([$1], [-Wno-error=]), [-1],
                  [m4_null_if([$2], [AT_BISON_CHECK_WARNINGS_($@)])])])

m4_define([AT_BISON_CHECK_WARNINGS_],
[[# Defining POSIXLY_CORRECT causes bison to complain if options are
# added after the grammar file name, so skip these checks in that
# case.
if test "$POSIXLY_CORRECT_IS_EXPORTED" = false; then
          ]AT_SAVE_SPECIAL_FILES[

  # To avoid expanding it repeatedly, store specified stdout.
  ]AT_DATA([expout], [$3])[

  # Run with -Werror.
  ]AT_BISON_CHECK_([$1[ -Werror]], [[1]], [expout], [stderr])[

  if test x"$PERL" != x; then
    # Build expected stderr up to and including the "warnings being
    # treated as errors" message.
    ]AT_DATA([[experr]], [$4])[
    "$PERL" -pi -e 's{(.*): warning:}{$][1: error:};' \
                -e 's{\[-W(.*)\]$}{@<:@-Werror=$][1@:>@}' \
                    experr
    ]AT_CHECK([[sed 's,.*/$,,' stderr 1>&2]], [[0]], [[]], [experr])[

    # Now check --warnings=error.
    cp stderr experr
    ]AT_BISON_CHECK_([$1[ --warnings=error]], [[1]], [expout], [experr])[
  fi

  # Now check -Wnone and --warnings=none by making sure that
  # -Werror doesn't change the exit status when -Wnone or
  # --warnings=none is specified.  With traces disabled, there should
  # be no output on stderr.
  ]AT_BISON_CHECK_([$1[ -Wnone,none -Werror --trace=none]], [[0]], [expout])[
  ]AT_BISON_CHECK_([$1[ --warnings=none -Werror --trace=none]], [[0]], [expout])[

  ]AT_RESTORE_SPECIAL_FILES[
fi]dnl
])

# AT_BISON_CHECK_NO_XML(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# --------------------------------------------------------
# Same as AT_BISON_CHECK except don't perform XML/XSLT checks.  This is useful
# when a tortured grammar's XML is known to be too large for xsltproc to
# handle.
m4_define([AT_BISON_CHECK_NO_XML],
[AT_CHECK(AT_SET_ENV_IF([$2]) [[bison --color=no -fno-caret ]]$@)
AT_BISON_CHECK_WARNINGS($@)])

# AT_BISON_CHECK_XML(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# -----------------------------------------------------
# Run AT_BISON_CHECK's XML/XSLT checks if $BISON_TEST_XML=1 and $XSLTPROC is
# defined.  It doesn't make sense to invoke this macro if Bison is expected to
# have a non-zero exit status.
m4_define([AT_BISON_CHECK_XML],
[[if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then]
  AT_SAVE_SPECIAL_FILES
  [mkdir xml-tests]
  m4_pushdef([AT_BISON_ARGS],
             [m4_bpatsubsts([[$1]],
                            [--report(-file)?=[^][ ]*], [],
                            [--graph=[^][ ]*], [],
                            [--xml=[^][ ]*], [])])dnl
  # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  AT_BISON_CHECK_([[--report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.gv ]]AT_BISON_ARGS,
           [[0]], [ignore], [ignore])
  AT_BISON_CHECK_([[--xml=xml-tests/test.xml ]]AT_BISON_ARGS,
           [[0]], [ignore], [ignore])
  m4_popdef([AT_BISON_ARGS])dnl
  [cp xml-tests/test.output expout]
  AT_CHECK([[$XSLTPROC \
             `]]AT_SET_ENV[[ bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml]], [[0]], [expout])
  [sort xml-tests/test.gv > expout]
  AT_CHECK([[$XSLTPROC \
             `]]AT_SET_ENV[[ bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml | sort]], [[0]], [expout])
  [rm -rf xml-tests expout]
  AT_RESTORE_SPECIAL_FILES
[fi]])


# AT_SET_ENV_IF(EXIT-STATUS)
# --------------------------
# Put this before a Bison invocation to set the environment to:
# - define COLUMNS to make the test suite independent of the user's
#   environment;
# - keep Valgrind from complaining about reachable memory (when
#   EXIT-STATUS is not 0).
#
# Do not quote invocations of this macro within the first argument of AT_CHECK.
# The triple quoting below will cause test cases to fail if you do.  If you do
# so anyway but also decrease the quoting below to avoid that problem, AT_CHECK
# will then fail to shell-escape its contents when attempting to print them.
# The testsuite verbose output, at least, will be incorrect, but nothing may
# fail to make sure you notice.
m4_define([AT_SET_ENV_IF],
[[[COLUMNS=1000; export COLUMNS;]] m4_null_if($1, [], [[[VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS; ]]])])


# AT_SET_ENV
# ----------
# See above.
m4_define([AT_SET_ENV],
[AT_SET_ENV_IF([1])])

## ------------------------ ##
## Compiling C, C++ Files.  ##
## ------------------------ ##


# AT_COMPILE(OUTPUT, [SOURCES = OUTPUT.c], [EXTRA-COMPILER-FLAGS])
# ----------------------------------------------------------------
# Compile SOURCES into OUTPUT.
#
# If OUTPUT does not contain '.', assume that we are linking too,
# otherwise pass "-c"; this is a hack.  The default SOURCES is OUTPUT
# with trailing .o removed, and ".c" appended.
m4_define([AT_COMPILE],
[AT_SKIP_IF([[! $BISON_C_WORKS]])
AT_CHECK(m4_join([ ],
                 [$CC $CFLAGS $CPPFLAGS $3],
                 [m4_bmatch([$1], [[.]], [-c], [$LDFLAGS])],
                 [-o $1],
                 [m4_default([$2], [m4_bpatsubst([$1], [\.o$]).c])],
                 [m4_bmatch([$1], [[.]], [], [$LIBS])]),
         0, [ignore], [ignore])])


# AT_COMPILE_CXX(OUTPUT, [SOURCES = OUTPUT.cc], [EXTRA-COMPILER-FLAGS])
# ---------------------------------------------------------------------
# Compile SOURCES into OUTPUT.  If the C++ compiler does not work,
# ignore the test.
#
# If OUTPUT does not contain '.', assume that we are linking too,
# otherwise pass "-c"; this is a hack.  The default SOURCES is OUTPUT
# with trailing ".o" removed, and ".cc" appended.
m4_define([AT_COMPILE_CXX],
[AT_KEYWORDS(c++)
AT_SKIP_IF([[! $BISON_CXX_WORKS]])
AT_CHECK(m4_join([ ],
                 [$CXX $CXXFLAGS $CPPFLAGS $3],
                 [m4_bmatch([$1], [[.]], [-c], [$LDFLAGS])],
                 [-o $1],
                 [m4_default([$2], [m4_bpatsubst([$1], [\.o$]).cc])],
                 [m4_bmatch([$1], [[.]], [], [$LIBS])]),
         0, [ignore], [ignore])])


# AT_COMPILE_D(OUTPUT, [SOURCES = OUTPUT.d], [EXTRA-COMPILER-FLAGS])
# -------------------------------------------------------------------
# Compile SOURCES into OUTPUT.  If the C++ compiler does not work,
# ignore the test.
#
# If OUTPUT does not contain '.', assume that we are linking too,
# otherwise pass "-c"; this is a hack.  The default SOURCES is OUTPUT
# with trailing ".o" removed, and ".cc" appended.
m4_define([AT_COMPILE_D],
[AT_KEYWORDS(d)
AT_SKIP_IF([[! $BISON_DC_WORKS]])
AT_CHECK(m4_join([ ],
                 [$DC $DCFLAGS $3],
                 [m4_bmatch([$1], [[.]], [-c])],
                 [-of$1],
                 [m4_default([$2], [m4_bpatsubst([$1], [\.o$]).d])]),
         0, [ignore], [ignore])])


# AT_JAVA_COMPILE(SOURCES)
# ------------------------
# Compile SOURCES into Java class files.  Skip the test if java or javac
# is not installed.
m4_define([AT_JAVA_COMPILE],
[AT_KEYWORDS(java)
AT_SKIP_IF([[test -z "$CONF_JAVAC"]])
AT_SKIP_IF([[test -z "$CONF_JAVA"]])
AT_CHECK([[$SHELL ../../../javacomp.sh ]$1],
         [[0]], [ignore], [ignore])])


# AT_LANG_FOR_EACH_STD(BODY)
# --------------------------
m4_define([AT_LANG_FOR_EACH_STD],  [AT_LANG_DISPATCH([$0], $@)])


# AT_LANG_COMPILE(OUTPUT, [SOURCES = OUTPUT.c], [EXTRA-COMPILER-FLAGS])
# ---------------------------------------------------------------------
# Compile SOURCES into OUTPUT.  Skip if compiler does not work.
#
# If OUTPUT does not contain '.', assume that we are linking too,
# otherwise pass "-c"; this is a hack.  The default SOURCES is OUTPUT
# with trailing .o removed, and ".c"/".cc" appended.
m4_define([AT_LANG_COMPILE],  [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_LANG_COMPILE(c)],    [AT_COMPILE([$1], [$2], [$3])])
m4_define([AT_LANG_COMPILE(c++)],  [AT_COMPILE_CXX([$1], [$2], [$3])])
m4_define([AT_LANG_COMPILE(d)],    [AT_COMPILE_D([$1], [$2], [$3])])
m4_define([AT_LANG_COMPILE(java)], [AT_JAVA_COMPILE([$1.java], [$2], [$3])])


# AT_LANG_EXT
# -----------
# The file extension corresponding to the language: c, cc, or java.
m4_define([AT_LANG_EXT],  [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_LANG_EXT(c)],    [c])
m4_define([AT_LANG_EXT(c++)],  [cc])
m4_define([AT_LANG_EXT(d)],    [d])
m4_define([AT_LANG_EXT(java)], [java])


# AT_LANG_HDR
# -----------
# The header file extension corresponding to the language: c, cc.
m4_define([AT_LANG_HDR],  [AT_LANG_DISPATCH([$0], $@)])
m4_define([AT_LANG_HDR(c)],    [h])
m4_define([AT_LANG_HDR(c++)],  [hh])


# AT_FULL_COMPILE(OUTPUT, [OTHER1], [OTHER2],
#                 [$4: EXTRA-COMPILER-FLAGS, [$5: EXTRA-BISON-FLAGS])
# -------------------------------------------------------------------
# Compile OUTPUT.y to OUTPUT.c, OUTPUT.cc, or OUTPUT.java, and then
# compile it to OUTPUT or OUTPUT.class.  If OTHER is specified, compile
# OUTPUT-OTHER.c, OUTPUT-OTHER.cc, or OUTPUT-OTHER.java to OUTPUT or
# OUTPUT.java along with it.  Relies on AT_CXX_IF and
# AT_JAVA_IF.
m4_define([AT_FULL_COMPILE],
[AT_BISON_CHECK([$5 -o $1.AT_LANG_EXT $1.y])
 AT_LANG_COMPILE([$1],
                 m4_join([ ],
                         [$1.AT_LANG_EXT],
                         m4_ifval($2, [[$1-$2.]AT_LANG_EXT]),
                         m4_ifval($3, [[$1-$3.]AT_LANG_EXT])),
                 [$4])])



# AT_SKIP_IF_CANNOT_LINK_C_AND_CXX
# --------------------------------
# Check that we can link together C and C++ objects.
m4_define([AT_SKIP_IF_CANNOT_LINK_C_AND_CXX],
[AT_DATA([c-and-cxx.h],
[[#ifdef __cplusplus
extern "C"
{
#endif
  int fortytwo (void);
#ifdef __cplusplus
}
#endif
]])
AT_DATA([c-only.c],
[[#include "c-and-cxx.h"
int
main (void)
{
  return fortytwo () == 42 ? 0 : 1;
}
]])
AT_DATA([cxx-only.cc],
[[#include "c-and-cxx.h"
int fortytwo ()
{
  return 42;
}
]])
AT_COMPILE([c-only.o], [c-only.c])
AT_COMPILE_CXX([cxx-only.o], [cxx-only.cc])
AT_CHECK([$CXX $CXXFLAGS $CPPFLAGS $LDFLAGS c-only.o cxx-only.o -o c-and-cxx ||
          exit 77], [0], [ignore], [ignore])
AT_C_PARSER_CHECK([c-and-cxx])
])


# AT_REQUIRE_CXX_STD(STD, [IF-FAIL = SKIP])
# -----------------------------------------
# Skip unless this compiler supports at least C++ STD (e.g., "11",
# "14", etc.).
m4_define([AT_REQUIRE_CXX_STD],
[AT_DATA([check.cc],
[[int main ()
{
#if !defined __cplusplus || __cplusplus < ]m4_case([$1],
    [98], [199711],
    [03], [199711],
    [11], [201103],
    [14], [201402],
    [17], [201703],
    [2a], [201709],
    [m4_fatal([$0: invalid arguments: $@])])[
  return 1;
#else
  return 0;
#endif
}
]])
AT_COMPILE_CXX([check])
AT_CHECK([@&t@./check], [ignore])
m4_ifval([$2],
         [if test $at_status != 0; then
            $2
          fi],
         [AT_SKIP_IF([test $at_status != 0])])
])


# AT_SKIP_IF_EXCEPTION_SUPPORT_IS_POOR
# ------------------------------------
# Check that we can expect exceptions to be handled properly.
# GCC 4.3 and 4.4 fail https://trac.macports.org/ticket/40853.
m4_define([AT_SKIP_IF_EXCEPTION_SUPPORT_IS_POOR],
[AT_DATA_SOURCE([exceptions.cc],
[[#include <iostream>
#include <stdexcept>

void foo ()
{
  try
    {
      throw std::runtime_error ("foo");
    }
  catch (...)
    {
      std::cerr << "Inner caught\n";
      throw;
    }
}

int main ()
{
  try
    {
      foo ();
    }
  catch (...)
    {
      std::cerr << "Outer caught\n";
      return 0;
    }
  return 1;
}
]])
AT_COMPILE_CXX([exceptions])
# The "empty" quadrigraph is to protect from cfg.mk's sc_at_parser_check.
AT_CHECK([@&t@./exceptions || exit 77], [0], [], [ignore])
])


## ---------------------------- ##
## Running a generated parser.  ##
## ---------------------------- ##


# AT_C_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# --------------------------------------------------------------
# So that we can run './testsuite PREPARSER='valgrind -q' for instance.
#
# Get rid of spurious messages when compiled with --coverage:
# +profiling:/[...]/lib/fprintf.gcda:Merge mismatch for summaries
m4_define([AT_C_PARSER_CHECK],
[AT_CHECK([$5 $PREPARSER ./$1], [$2], [$3], [stderr])
AT_CHECK([sed >&2 -e '/^profiling:.*:Merge mismatch for summaries/d' stderr],
         [0], [], [$4])
])


# AT_JAVA_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# -----------------------------------------------------------------
m4_define([AT_JAVA_PARSER_CHECK],
[AT_CHECK([$5[ $SHELL ../../../javaexec.sh ]$1], [$2], [$3], [$4])])


# AT_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# ------------------------------------------------------------
# If we know we are in Java (via AT_BISON_OPTION_PUSHDEFS/POPDEFS),
# run AT_JAVA_PARSER_CHECK, otherwise AT_C_PARSER_CHECK.
m4_define([AT_PARSER_CHECK],
[m4_ifdef([AT_JAVA_IF],
          [AT_JAVA_IF([AT_JAVA_PARSER_CHECK($@)],
                      [AT_C_PARSER_CHECK($@)])],
          [AT_C_PARSER_CHECK($@)])])


# AT_TEST_TABLES_AND_PARSE(TITLE, COND-VALUE, TEST-SPEC,
#                          DECLS, GRAMMAR, INPUT,
#                          BISON-STDERR, TABLES-OR-LAST-STATE,
#                          [OTHER-CHECKS],
#                          [PARSER-EXIT-VALUE],
#                          [PARSER-STDOUT], [PARSER-STDERR])
# -------------------------------------------------------------
# Using TITLE as the test group title, check the generated parser tables
# and parser for a specified grammar file under a condition labeled by
# COND-VALUE.
#
# TEST-SPEC is a comma-delimited list of attributes of this test.  Each
# recognized attribute is described below where it is relevant.
#
# Insert DECLS and GRAMMAR into the declarations and grammar section of
# the grammar file.  Insert basic yyerror, yylex, and main function
# definitions as well.  Hardcode yylex to return the (possibly empty)
# comma-delimited series of tokens in INPUT followed by token 0.
#
# If TEST-SPEC contains the attribute no-xml, then invoke bison using
# AT_BISON_CHECK_NO_XML.  Otherwise, invoke bison using AT_BISON_CHECK.
# On the bison command-line, specify `--report=all --defines'.  Check
# that Bison exits with value 0, has no stdout, and has stderr
# BISON-STDERR.
#
# If TEST-SPEC contains the attribute 'last-state', check that the value
# of TABLES-OR-LAST-STATE is the index of the last state generated for
# the grammar; in other words, check the number of states (minus one).
# Otherwise, check that everything in the '.output' file starting with
# the definition of state 0 is the same as the entire value of
# TABLES-OR-LAST-STATE.
#
# Expand the M4 in OTHER-CHECKS to perform additional checks of the
# '.output' file, which is named 'input.output', and/or grammar file,
# which is named 'input.y'.
#
# Finally, compile the generated parser and then run it using
# AT_PARSER_CHECK with PARSER-EXIT-VALUE, PARSER-STDOUT, and
# PARSER-STDERR as the 2nd-4th arguments.
#
# As a precondition, you must properly double-quote all arguments that
# are to be interpreted as strings.
#
# AT_COND_CASE (when appearing in single-quoted segments of arguments)
# invokes m4_case with its own arguments but COND-VALUE inserted as the
# first argument.  This is useful, for example, when wrapping multiple
# AT_TEST_TABLES_AND_PARSE invocations, each representing a different
# condition, in another macro.
#
# For example:
#
#   # AT_TEST_SYNTAX_ERROR(DESCRIPTION, DECLS, GRAMMAR, INPUT, LAST-STATE,
#   #                      PARSER-EXIT-VALUE, PARSER-STDOUT, PARSER-STDERR)
#   # ---------------------------------------------------------------------
#   m4_define([AT_TEST_SYNTAX_ERROR],
#   [
#     AT_TEST_TABLES_AND_PARSE([$1[ with %define parse.error verbose]], [[verbose]],
#                              [[last-state]],
#                              [[%define parse.error verbose ]$2], [$3], [$4],
#                              [[]], [$5], [], [$6], [$7], [$8])
#     AT_TEST_TABLES_AND_PARSE([$1[ with no %define parse.error verbose]], [[no verbose]],
#                              [[last-state]],
#                              [$2], [$3], [$4],
#                              [[]], [$5], [], [$6], [$7], [$8])
#   ])
#
#   AT_TEST_SYNTAX_ERROR([[Single Char Grammar]],
#                        [[%token 'b']], [[start: 'a' ;]], [['a', 'b']],
#                        [[3]],
#                        [[1]], [[]],
#                        [AT_COND_CASE([[no verbose]],
#                                      [[syntax error
#   ]],
#                                      [[syntax error, unexpected 'b', expecting $end
#   ]])])
m4_define([AT_TEST_TABLES_AND_PARSE],
[m4_pushdef([AT_COND_CASE], [m4_case([$2], $][@)])

AT_SETUP([$1])
AT_BISON_OPTION_PUSHDEFS([$4])
AT_DATA_GRAMMAR([[input.y]],
[[%code {
  ]AT_YYERROR_DECLARE[
  ]AT_YYLEX_DECLARE[
}

]$4[

%%

]$5[

%%
]AT_YYERROR_DEFINE[
static int
yylex (void)
{
  static int const input[] = {
    ]m4_if([$6], [], [], [$6], [[]], [], [$6[, ]])[0
  };
  static int const *inputp = input;
  return *inputp++;
}

]AT_MAIN_DEFINE[
]])

# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 through 12 expand to properly quoted
# strings.

m4_if(m4_index(m4_quote($3), [no-xml]), -1,
      [AT_BISON_CHECK],
      [AT_BISON_CHECK_NO_XML])([[-Wall --report=all --defines -o input.c input.y]],
                               [0], [], m4_dquote($7))

m4_if(m4_index(m4_quote($3), [last-state]), -1,
      [AT_CHECK([[sed -n '/^State 0$/,$p' input.output]], [[0]],
                m4_dquote($8))],
      [AT_CHECK([[sed -n 's/^State //p' input.output | tail -1]], [[0]],
                m4_dquote($8)[[
]])])

$9

# Canonical LR generates very large tables, resulting in very long
# files with #line directives that may overflow what the standards
# (C90 and C++98) guarantee: 32767.  In that case, GCC's -pedantic
# will issue an error.
#
# There is no "" around `wc` since some wc indent the result.
m4_bmatch([$4], [%define lr.type canonical-lr],
[if test 32767 -lt `wc -l < input.c`; then
  CFLAGS=`echo " $CFLAGS " | sed -e 's/ -pedantic / /'`
  CXXFLAGS=`echo " $CXXFLAGS " | sed -e 's/ -pedantic / /'`
fi])
AT_COMPILE([[input]])

AT_PARSER_CHECK([[input]],
                m4_ifval([$10], [m4_dquote($10)]),
                m4_ifval([$11], [m4_dquote($11)]),
                m4_ifval([$12], [m4_dquote($12)]))

AT_BISON_OPTION_POPDEFS
AT_CLEANUP

m4_popdef([AT_COND_CASE])])



# AT_SETS_CHECK(INPUT, SETS, EXPECTED)
# ------------------------------------
# Extract the information about the grammar sets from a bison
# trace output (INPUT), and compare to EXPECTED.
#
# And remember, there is no alternation in portable sed.
m4_define([AT_SETS_CHECK],
[AT_DATA([extract.sed],
[[#n
]m4_foreach([m4_Set], [$2], [[
/^]m4_Set[/ {
   :]m4_substr(m4_Set, 0, 7)[
   p
   n
   /^ *$/ !b ]m4_substr(m4_Set, 0, 7)[
}
]])])

AT_CHECK([sed -f extract.sed $1], 0, [$3])
])




## ----------------------- ##
## Launch the test suite.  ##
## ----------------------- ##

AT_INIT

# AT_SETUP([TITLE])
# -----------------
# Redefine AT_SETUP to be more concise.  Must be done after AT_INIT.
m4_copy_force([AT_SETUP], [B4_SETUP])
m4_define([AT_SETUP],
[B4_SETUP(m4_expand([AT_SETUP_STRIP([[$1]])]))])

# Cannot assign CC and CFLAGS here, since atlocal is loaded after
# options are processed, so we don't know the value of CXX and
# CXXFLAGS yet.
#
# Note that it also means that command line values for CXX and
# CXXFLAGS will not be propagated to CC and CFLAGS.
AT_ARG_OPTION([compile-c-with-cxx],
              [compile C parsers with the C++ compiler])

AT_COLOR_TESTS

AT_TESTED([bison])
