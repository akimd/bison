# Process this -*- Autotest -*- file with autom4te.

# Macros for the GNU Bison Test suite.

# Copyright (C) 2003-2011 Free Software Foundation, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# We want a recent Autotest.
m4_version_prereq([2.58])


## ------------- ##
## Basic tests.  ##
## ------------- ##

# AT_MATCHES_CHECK(FILE, PERL-REGEXP, COUNT)
# ------------------------------------------
# Expect COUNT matches of the PERL-REGEXP in FILE.  The file is
# taken in "slurp" mode, i.e., one can match end-of-lines.
m4_define([AT_MATCHES_CHECK],
[AT_CHECK([perl -0777 -ne '
my $count = 0;
s{$2}{ ++$count; "" }gem;
printf "$count\n";' $1], [0], [$3
])])


## ------------------------------- ##
## Macros decoding Bison options.  ##
## ------------------------------- ##

# AT_LOC_PUSHDEF(FIRST-LINE, FIRST-COLUMN, LAST-LINE, LAST-COLUMN)
# ----------------------------------------------------------------
# Pushdef AT_LOC_(FIRST|LAST)_(LINE|COLUMN).
m4_define([AT_LOC_PUSHDEF],
[m4_pushdef([AT_LOC_FIRST_LINE],  [AT_LOC.$1])
m4_pushdef([AT_LOC_FIRST_COLUMN], [AT_LOC.$2])
m4_pushdef([AT_LOC_LAST_LINE],    [AT_LOC.$3])
m4_pushdef([AT_LOC_LAST_COLUMN],  [AT_LOC.$4])])

# AT_LOC_POPDEF
# -------------
# Popdef AT_LOC_(FIRST|LAST)_(LINE|COL).
m4_define([AT_LOC_POPDEF],
[m4_popdef([AT_LOC_FIRST_LINE])
m4_popdef([AT_LOC_FIRST_COLUMN])
m4_popdef([AT_LOC_LAST_LINE])
m4_popdef([AT_LOC_LAST_COLUMN])])



# AT_BISON_OPTION_PUSHDEFS([BISON-OPTIONS])
# -----------------------------------------
m4_define([AT_BISON_OPTION_PUSHDEFS],
[_AT_BISON_OPTION_PUSHDEFS($[1], $[2], [$1])])


# _AT_BISON_OPTION_PUSHDEFS($1, $2, [BISON-OPTIONS])
# --------------------------------------------------
# This macro works around the impossibility to define macros
# inside macros, because issuing `[$1]' is not possible in M4 :(.
# This sucks hard, GNU M4 should really provide M5 like $$1.
m4_define([_AT_BISON_OPTION_PUSHDEFS],
[m4_if([$1$2], $[1]$[2], [],
       [m4_fatal([$0: Invalid arguments: $@])])dnl
m4_pushdef([AT_DEFINES_IF],
[m4_bmatch([$3], [%defines], [$1], [$2])])
m4_pushdef([AT_SKEL_CC_IF],
[m4_bmatch([$3], [%language "[Cc]\+\+"\|%skeleton "[a-z0-9]+\.cc"], [$1], [$2])])
m4_pushdef([AT_SKEL_JAVA_IF],
[m4_bmatch([$3], [%language "[Jj][Aa][Vv][Aa]"\|%skeleton "[a-z0-9]+\.java"], [$1], [$2])])
m4_pushdef([AT_GLR_IF],
[m4_bmatch([$3], [%glr-parser\|%skeleton "glr\.], [$1], [$2])])
m4_pushdef([AT_LALR1_CC_IF],
[AT_SKEL_CC_IF([AT_GLR_IF([$2], [$1])], [$2])])
m4_pushdef([AT_GLR_CC_IF],
[AT_SKEL_CC_IF([AT_GLR_IF([$1], [$2])], [$2])])
# Using yacc.c?
m4_pushdef([AT_YACC_IF],
[m4_bmatch([$3], [%language\|%glr-parser\|%skeleton], [$2], [$1])])
m4_pushdef([AT_LEXPARAM_IF],
[m4_bmatch([$3], [%lex-param], [$1], [$2])])
m4_pushdef([AT_LOCATION_IF],
[m4_bmatch([$3], [%locations], [$1], [$2])])
m4_pushdef([AT_LOCATION_TYPE_IF],
[m4_bmatch([$3], [%define location_type], [$1], [$2])])
m4_pushdef([AT_PARAM_IF],
[m4_bmatch([$3], [%parse-param], [$1], [$2])])
m4_pushdef([AT_PURE_IF],
[m4_bmatch([$3], [%define  *api\.pure\|%pure-parser],
           [m4_bmatch([$3], [%define  *api\.pure *"?false"?], [$2], [$1])],
           [$2])])
m4_pushdef([AT_PURE_AND_LOC_IF],
[m4_bmatch([$3], [%locations], [AT_PURE_IF($@)], [$2])])
m4_pushdef([AT_GLR_OR_PARAM_IF],
[m4_bmatch([$3], [%glr-parser\|%parse-param], [$1], [$2])])
m4_pushdef([AT_NAME_PREFIX],
[m4_bmatch([$3], [%name-prefix ".*"],
           [m4_bregexp([$3], [name-prefix "\([^"]*\)"], [\1])],
           [yy])])
# yyerror receives the location if %location & %pure & (%glr or %parse-param).
m4_pushdef([AT_YYERROR_ARG_LOC_IF],
[AT_GLR_OR_PARAM_IF([AT_PURE_AND_LOC_IF([$1], [$2])],
		    [$2])])
# yyerror always sees the locations (when activated), except if
# (yacc & pure & !param).  FIXME: This is wrong.  See the manual.
m4_pushdef([AT_YYERROR_SEES_LOC_IF],
[AT_LOCATION_IF([AT_YACC_IF([AT_PURE_IF([AT_PARAM_IF([$1], [$2])],
					[$1])],
			    [$1])],
		[$2])])

# The interface is pure: either because %define api.pure, or because we
# are using the C++ parsers.
m4_pushdef([AT_PURE_LEX_IF],
[AT_PURE_IF([$1],
	    [AT_SKEL_CC_IF([$1], [$2])])])

AT_PURE_LEX_IF(
[m4_pushdef([AT_LOC], [(*llocp)])
 m4_pushdef([AT_VAL], [(*lvalp)])
 m4_pushdef([AT_LEX_FORMALS],
	    [YYSTYPE *lvalp[]AT_LOCATION_IF([, YYLTYPE *llocp])])
 m4_pushdef([AT_LEX_ARGS],
	    [lvalp[]AT_LOCATION_IF([, llocp])])
 m4_pushdef([AT_USE_LEX_ARGS],
	    [(void) lvalp;AT_LOCATION_IF([(void) llocp])])
 m4_pushdef([AT_LEX_PRE_FORMALS],
	    [AT_LEX_FORMALS, ])
 m4_pushdef([AT_LEX_PRE_ARGS],
	    [AT_LEX_ARGS, ])
],
[m4_pushdef([AT_LOC], [[(]AT_NAME_PREFIX[lloc)]])
 m4_pushdef([AT_VAL], [[(]AT_NAME_PREFIX[lval)]])
 m4_pushdef([AT_LEX_FORMALS],     [void])
 m4_pushdef([AT_LEX_ARGS],        [])
 m4_pushdef([AT_USE_LEX_ARGS],    [])
 m4_pushdef([AT_LEX_PRE_FORMALS], [])
 m4_pushdef([AT_LEX_PRE_ARGS],    [])
])

# Handle the different types of location components.

AT_SKEL_CC_IF(
  [AT_LOCATION_TYPE_IF(
    [AT_LOC_PUSHDEF([first.l], [first.c], [last.l], [last.c])],
    [AT_LOC_PUSHDEF([begin.line], [begin.column], [end.line], [end.column])])],
  [AT_LOC_PUSHDEF([first_line], [first_column], [last_line], [last_column])])

])# _AT_BISON_OPTION_PUSHDEFS


# AT_BISON_OPTION_POPDEFS
# -----------------------
m4_define([AT_BISON_OPTION_POPDEFS],
[m4_popdef([AT_LEX_PRE_ARGS])
m4_popdef([AT_LEX_PRE_FORMALS])
m4_popdef([AT_USE_LEX_ARGS])
m4_popdef([AT_LEX_ARGS])
m4_popdef([AT_LEX_FORMALS])
m4_popdef([AT_VAL])
m4_popdef([AT_LOC])
m4_popdef([AT_PURE_LEX_IF])
m4_popdef([AT_YYERROR_SEES_LOC_IF])
m4_popdef([AT_YYERROR_ARG_LOC_IF])
m4_popdef([AT_NAME_PREFIX])
m4_popdef([AT_GLR_OR_PARAM_IF])
m4_popdef([AT_PURE_AND_LOC_IF])
m4_popdef([AT_LOCATION_TYPE_IF])
m4_popdef([AT_LOCATION_IF])
m4_popdef([AT_PARAM_IF])
m4_popdef([AT_LEXPARAM_IF])
m4_popdef([AT_YACC_IF])
m4_popdef([AT_GLR_IF])
m4_popdef([AT_SKEL_CC_IF])
m4_popdef([AT_SKEL_JAVA_IF])
m4_popdef([AT_GLR_CC_IF])
m4_popdef([AT_LALR1_CC_IF])
m4_popdef([AT_DEFINES_IF])
AT_LOC_POPDEF
])# AT_BISON_OPTION_POPDEFS



## -------------------------- ##
## Generating Grammar Files.  ##
## -------------------------- ##

# AT_DATA_SOURCE_PROLOGUE
# ------------------------
# The prologue that should be included in any source code that is
# meant to be compiled.
m4_define([AT_DATA_SOURCE_PROLOGUE],
[[#include <config.h>
/* We don't need perfect functions for these tests. */
#undef malloc
#undef memcmp
#undef realloc
]])

# AT_DATA_GRAMMAR_PROLOGUE
# ------------------------
# The prologue that should be included in any grammar which parser is
# meant to be compiled.
m4_define([AT_DATA_GRAMMAR_PROLOGUE],
[[%code top {
]AT_DATA_SOURCE_PROLOGUE[]dnl
[}
]])

# AT_DATA_SOURCE(NAME, CONTENT)
# -----------------------------
# Generate the file NAME, which CONTENT is preceded by
# AT_DATA_SOURCE_PROLOGUE.
m4_define([AT_DATA_SOURCE],
[AT_DATA([$1],
[AT_DATA_SOURCE_PROLOGUE
$2])
])

# AT_DATA_GRAMMAR(NAME, CONTENT)
# ------------------------------
# Generate the file NAME, which CONTENT is preceded by
# AT_DATA_GRAMMAR_PROLOGUE.
m4_define([AT_DATA_GRAMMAR],
[AT_DATA([$1],
[AT_DATA_GRAMMAR_PROLOGUE
$2])
])

# AT_BISON_CHECK(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# -------------------------------------------------
# Check Bison by invoking `bison BISON_ARGS'.  BISON_ARGS should not contain
# shell constructs (such as redirection or pipes) that would prevent
# appending additional command-line arguments for bison. OTHER_AT_CHECK_ARGS
# are the usual remaining arguments to AT_CHECK: STATUS, STDOUT, etc.
#
# This macro or AT_BISON_CHECK_NO_XML should always be used whenever invoking
# Bison in the test suite.  For now it ensures that:
#
#   1. Valgrind doesn't report reachable memory when Bison is expected to have
#      a non-zero exit status since Bison doesn't always try to free all memory
#      in that case.
#
#   2. In the case of maintainer-xml-check, XML/XSLT output is compared with
#      --graph and --report=all output for every working grammar.
#
#   3. If stderr contains a warning, -Werror and --warnings=error
#      convert the warning to an error.
#
#   4. If stderr contains a warning, -Wnone and --warnings=none suppress it.
m4_define([AT_BISON_CHECK],
[m4_if(m4_quote($2), [0], [AT_BISON_CHECK_XML($@)],
       m4_quote($2), [], [AT_BISON_CHECK_XML($@)])
AT_BISON_CHECK_NO_XML($@)])

m4_define([AT_BISON_WERROR_MSG],
          [[bison: warnings being treated as errors]])

# AT_BISON_CHECK_NO_XML(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# --------------------------------------------------------
# Same as AT_BISON_CHECK except don't perform XML/XSLT checks.  This is useful
# when a tortured grammar's XML is known to be too large for xsltproc to
# handle.
m4_define([AT_BISON_CHECK_NO_XML],
[AT_CHECK(m4_if(m4_quote($2), [0], [], m4_quote($2), [], [],
                [AT_QUELL_VALGRIND ])[[bison ]]$@)
m4_if(m4_bregexp([$4], [: warning: ]), [-1], [],
      m4_quote(m4_if(m4_quote($2), [], [0], [$2])), [0], [[
        # POSIXLY_CORRECT=1 causes bison to complain if options are added
        # after the grammar file name, so skip these checks in that case.
        if test x"$POSIXLY_CORRECT" != x1; then
          # Don't interfere with caller's files.
          if test -f stderr; then mv stderr at-bison-check-stderr.bak; fi
          if test -f experr; then mv experr at-bison-check-experr.bak; fi
          if test -f expout; then mv expout at-bison-check-expout.bak; fi

          # To avoid expanding it repeatedly, store specified stdout.
          ]AT_DATA([expout], [$3])[

          # Run with -Werror.
          ]AT_CHECK(AT_QUELL_VALGRIND[[ bison ]$1[ -Werror]],
                    [[1]], [expout], [stderr])[

          # Build expected stderr up to and including the "warnings being
          # treated as errors" message.
          ]AT_DATA([[at-bison-check-warnings]], [$4])[
          at_bison_check_first="` \
            sed -n '/: warning: /=' at-bison-check-warnings \
            | sed -n 1p \
          `"
          at_bison_check_first_tmp="` \
            sed -n '/conflicts: [0-9].*reduce$/=' at-bison-check-warnings \
            | sed -n 1p \
          `"
          if test $at_bison_check_first_tmp -lt $at_bison_check_first; then
            at_bison_check_first=$at_bison_check_first_tmp
          fi
          if test $at_bison_check_first -gt 1; then
            sed -n "1,`expr $at_bison_check_first - 1`"p \
              at-bison-check-warnings > experr
          fi
          echo ']AT_BISON_WERROR_MSG[' >> experr

          # Finish building expected stderr and check.  Unlike warnings,
          # complaints cause bison to exit early.  Thus, with -Werror, bison
          # does not necessarily report all warnings that it does without
          # -Werror, but it at least reports one.
          at_bison_check_last="`sed -n '$=' stderr`"
          if test x"$at_bison_check_last" = x; then
            at_bison_check_last=1
          fi
          at_bison_check_last="`expr $at_bison_check_last - 1`"
          sed -n "$at_bison_check_first,$at_bison_check_last"p \
            at-bison-check-warnings >> experr
          ]AT_CHECK([[sed 's,.*/\(]AT_BISON_WERROR_MSG[\)$,\1,' \
                      stderr 1>&2]], [[0]], [[]], [experr])[

          # Now check --warnings=error.
          cp stderr experr
          ]AT_CHECK(AT_QUELL_VALGRIND[[ bison ]$1[ --warnings=error]],
                    [[1]], [expout], [experr])[

          # Now check -Wnone and --warnings=none by making sure that
          # -Werror doesn't change the exit status when -Wnone or
          # --warnings=none is specified.
          ]AT_CHECK(AT_QUELL_VALGRIND[[ bison ]$1[ -Wnone -Werror]],
                    [[0]], [expout])[
          ]AT_CHECK(AT_QUELL_VALGRIND[[ bison ]$1[ --warnings=none \
                    -Werror]], [[0]], [expout])[

          # Restore caller's files.
          if test -f at-bison-check-expout.bak; then
            mv at-bison-check-expout.bak expout
          fi
          if test -f at-bison-check-experr.bak; then
            mv at-bison-check-experr.bak experr
          fi
          if test -f at-bison-check-stderr.bak; then
            mv at-bison-check-stderr.bak stderr
          fi
        fi
      ]])
])

# AT_BISON_CHECK_XML(BISON_ARGS, [OTHER_AT_CHECK_ARGS])
# -----------------------------------------------------
# Run AT_BISON_CHECK's XML/XSLT checks if $BISON_TEST_XML=1 and $XSLTPROC is
# defined.  It doesn't make sense to invoke this macro if Bison is expected to
# have a non-zero exit status.
m4_define([AT_BISON_CHECK_XML],
[[if test x"$BISON_TEST_XML" = x1 && test x"$XSLTPROC" != x""; then
  mkdir xml-tests]
  m4_pushdef([AT_BISON_ARGS],
             [m4_bpatsubsts([[$1]],
                            [--report(-file)?=[^][ ]*], [],
                            [--graph=[^][ ]*], [],
                            [--xml=[^][ ]*], [])])dnl
  # Don't combine these Bison invocations since we want to be sure that
  # --report=all isn't required to get the full XML file.
  AT_CHECK([[bison --report=all --report-file=xml-tests/test.output \
             --graph=xml-tests/test.dot ]]AT_BISON_ARGS,
           [[0]], [ignore], [ignore])
  AT_CHECK([[bison --xml=xml-tests/test.xml ]]AT_BISON_ARGS,
           [[0]], [ignore], [ignore])
  m4_popdef([AT_BISON_ARGS])dnl
  [cp xml-tests/test.output expout]
  AT_CHECK([[$XSLTPROC \
             `]]AT_QUELL_VALGRIND[[ bison --print-datadir`/xslt/xml2text.xsl \
             xml-tests/test.xml]], [[0]], [expout])
  [cp xml-tests/test.dot expout]
  AT_CHECK([[$XSLTPROC \
             `]]AT_QUELL_VALGRIND[[ bison --print-datadir`/xslt/xml2dot.xsl \
             xml-tests/test.xml]], [[0]], [expout])
  [rm -rf xml-tests expout
fi]])

# AT_QUELL_VALGRIND
# -----------------
# Put this before a Bison invocation to keep Valgrind from complaining about
# reachable memory.
#
# Do not quote invocations of this macro within the first argument of AT_CHECK.
# The triple quoting below will cause test cases to fail if you do.  If you do
# so anyway but also decrease the quoting below to avoid that problem, AT_CHECK
# will then fail to shell-escape its contents when attempting to print them.
# The testsuite verbose output, at least, will be incorrect, but nothing may
# fail to make sure you notice.
m4_define([AT_QUELL_VALGRIND],
[[[VALGRIND_OPTS="$VALGRIND_OPTS --leak-check=summary --show-reachable=no"; export VALGRIND_OPTS;]]])

## ------------------------ ##
## Compiling C, C++ Files.  ##
## ------------------------ ##


# AT_COMPILE(OUTPUT, [SOURCES = OUTPUT.c])
# ----------------------------------------
# Compile SOURCES into OUTPUT.  If OUTPUT does not contain '.',
# assume that we are linking too; this is a hack.
m4_define([AT_COMPILE],
[AT_CHECK([$CC $CFLAGS $CPPFLAGS m4_bmatch([$1], [[.]], [], [$LDFLAGS ])-o $1 m4_default([$2], [$1.c])[]m4_bmatch([$1], [[.]], [], [ $LIBS])],
	   0, [ignore], [ignore])])

# AT_COMPILE_CXX(OUTPUT, [SOURCES = OUTPUT.cc])
# --------------------------------------------
# Compile SOURCES into OUTPUT.  If OUTPUT does not contain '.',
# assume that we are linking too; this is a hack.
# If the C++ compiler does not work, ignore the test.
m4_define([AT_COMPILE_CXX],
[AT_KEYWORDS(c++)
AT_CHECK([$BISON_CXX_WORKS], 0, ignore, ignore)
AT_CHECK([$CXX $CXXFLAGS $CPPFLAGS m4_bmatch([$1], [[.]], [], [$LDFLAGS ])-o $1 m4_default([$2], [$1.cc])[]m4_bmatch([$1], [[.]], [], [ $LIBS])],
	 0, [ignore], [ignore])])

# AT_JAVA_COMPILE(SOURCES)
# ------------------------
# Compile SOURCES into Java class files.  Skip the test if java or javac
# is not installed.
m4_define([AT_JAVA_COMPILE],
[AT_KEYWORDS(java)
AT_CHECK([[test -n "$CONF_JAVA" || exit 77
           test -n "$CONF_JAVAC" || exit 77]])
AT_CHECK([[$SHELL ../../../javacomp.sh ]$1],
         [[0]], [ignore], [ignore])])

# AT_FULL_COMPILE(OUTPUT, [OTHER])
# --------------------------------
# Compile OUTPUT.y to OUTPUT.c, OUTPUT.cc, or OUTPUT.java, and then
# compile it to OUTPUT or OUTPUT.class.  If OTHER is specified, compile
# OUTPUT-OTHER.c, OUTPUT-OTHER.cc, or OUTPUT-OTHER.java to OUTPUT or
# OUTPUT.java along with it.  Relies on AT_SKEL_CC_IF and
# AT_SKEL_JAVA_IF.
m4_define([AT_FULL_COMPILE], [
  AT_SKEL_JAVA_IF([
    AT_BISON_CHECK([[-o ]$1[.java ]$1[.y]])
    AT_JAVA_COMPILE([$1[.java]]m4_ifval($2,
                                        [[$1[.java ]$1[-]$2[.java]]]))
  ], [
    AT_SKEL_CC_IF([
      AT_BISON_CHECK([[-o ]$1[.cc ]$1[.y]])
      AT_COMPILE_CXX([$1]m4_ifval($2, [, [$1[.cc ]$1[-]$2[.cc]]]))
    ], [
      AT_BISON_CHECK([[-o ]$1[.c ]$1[.y]])
      AT_COMPILE([$1]m4_ifval($2, [, [$1[.c ]$1[-]$2[.c]]]))
    ])
  ])
])


## ---------------------------- ##
## Running a generated parser.  ##
## ---------------------------- ##

# AT_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# ------------------------------------------------------------
# So that we can run `./testsuite PREPARSER='valgrind -q' for instance.
m4_define([AT_PARSER_CHECK],
[AT_CHECK([$5 $PREPARSER $1], [$2], [$3], [$4])])

# AT_JAVA_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# -----------------------------------------------------------------
m4_define([AT_JAVA_PARSER_CHECK],
[AT_CHECK([$5[ $SHELL ../../../javaexec.sh ]$1], [$2], [$3], [$4])])

# AT_TEST_TABLES_AND_PARSE(TITLE, COND-VALUE, TEST-SPEC,
#                          DECLS, GRAMMAR, INPUT,
#                          BISON-STDERR, TABLES-OR-LAST-STATE,
#                          [OTHER-CHECKS],
#                          [PARSER-EXIT-VALUE],
#                          [PARSER-STDOUT], [PARSER-STDERR])
# -------------------------------------------------------------
# Using TITLE as the test group title, check the generated parser tables
# and parser for a specified grammar file under a condition labeled by
# COND-VALUE.
#
# TEST-SPEC is a comma-delimited list of attributes of this test.  Each
# recognized attribute is described below where it is relevant.
#
# Insert DECLS and GRAMMAR into the declarations and grammar section of
# the grammar file.  Insert basic yyerror, yylex, and main function
# definitions as well.  Hardcode yylex to return the (possibly empty)
# comma-delimited series of tokens in INPUT followed by token 0.
#
# If TEST-SPEC contains the attribute no-xml, then invoke bison using
# AT_BISON_CHECK_NO_XML.  Otherwise, invoke bison using AT_BISON_CHECK.
# On the bison command-line, specify `--report=all --defines'.  Check
# that Bison exits with value 0, has no stdout, and has stderr
# BISON-STDERR.
#
# If TEST-SPEC contains the attribute `last-state', check that the value
# of TABLES-OR-LAST-STATE is the index of the last state generated for
# the grammar; in other words, check the number of states (minus one).
# Otherwise, check that everything in the `.output' file starting with
# the definition of state 0 is the same as the entire value of
# TABLES-OR-LAST-STATE.
#
# Expand the M4 in OTHER-CHECKS to perform additional checks of the
# `.output' file, which is named `input.output', and/or grammar file,
# which is named `input.y'.
#
# Finally, compile the generated parser and then run it using
# AT_PARSER_CHECK with PARSER-EXIT-VALUE, PARSER-STDOUT, and
# PARSER-STDERR as the 2nd-4th arguments.
#
# As a precondition, you must properly double-quote all arguments that
# are to be interpreted as strings.
#
# AT_COND_CASE (when appearing in single-quoted segments of arguments)
# invokes m4_case with its own arguments but COND-VALUE inserted as the
# first argument.  This is useful, for example, when wrapping multiple
# AT_TEST_TABLES_AND_PARSE invocations, each representing a different
# condition, in another macro.
#
# For example:
#
#   # AT_TEST_SYNTAX_ERROR(DESCRIPTION, DECLS, GRAMMAR, INPUT, LAST-STATE,
#   #                      PARSER-EXIT-VALUE, PARSER-STDOUT, PARSER-STDERR)
#   # ---------------------------------------------------------------------
#   m4_define([AT_TEST_SYNTAX_ERROR],
#   [
#     AT_TEST_TABLES_AND_PARSE([$1[ with %error-verbose]], [[verbose]],
#                              [[last-state]],
#                              [[%error-verbose ]$2], [$3], [$4],
#                              [[]], [$5], [], [$6], [$7], [$8])
#     AT_TEST_TABLES_AND_PARSE([$1[ with no %error-verbose]], [[no verbose]],
#                              [[last-state]],
#                              [$2], [$3], [$4],
#                              [[]], [$5], [], [$6], [$7], [$8])
#   ])
#
#   AT_TEST_SYNTAX_ERROR([[Single Char Grammar]],
#                        [[%token 'b']], [[start: 'a' ;]], [['a', 'b']],
#                        [[3]],
#                        [[1]], [[]],
#                        [AT_COND_CASE([[no verbose]],
#                                      [[syntax error
#   ]],
#                                      [[syntax error, unexpected 'b', expecting $end
#   ]])])
m4_define([AT_TEST_TABLES_AND_PARSE],
[m4_pushdef([AT_COND_CASE], [m4_case([$2], $][@)])

AT_SETUP([$1])

AT_DATA_GRAMMAR([[input.y]],
[[%code {
  #include <stdio.h>
  static void yyerror (char const *msg);
  static int yylex (void);
}

]$4[

%%

]$5[

%%

static void
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
}

static int
yylex (void)
{
  static int const input[] = {
    ]m4_if([$6], [], [], [$6], [[]], [], [$6[, ]])[0
  };
  static int const *inputp = input;
  return *inputp++;
}

int
main (void)
{
  return yyparse ();
}
]])

# In some versions of Autoconf, AT_CHECK invokes AS_ESCAPE before
# expanding macros, so it corrupts some special characters in the
# macros.  To avoid this, expand now and pass it the result with proper
# string quotation.  Assume args 7 thru 12 expand to properly quoted
# strings.

m4_if(m4_index(m4_quote($3), [no-xml]), -1,
      [AT_BISON_CHECK],
      [AT_BISON_CHECK_NO_XML])([[--report=all --defines -o input.c input.y]],
                               [0], [], m4_dquote($7))

m4_if(m4_index(m4_quote($3), [last-state]), -1,
      [AT_CHECK([[sed -n '/^state 0$/,$p' input.output]], [[0]],
                m4_dquote($8))],
      [AT_CHECK([[sed -n 's/^state //p' input.output | tail -1]], [[0]],
                m4_dquote($8)[[
]])])

$9

AT_COMPILE([[input]])

AT_PARSER_CHECK([[./input]],
                m4_ifval([$10], [m4_dquote($10)]),
                m4_ifval([$11], [m4_dquote($11)]),
                m4_ifval([$12], [m4_dquote($12)]))

AT_CLEANUP

m4_popdef([AT_COND_CASE])])



## ----------------------- ##
## Launch the test suite.  ##
## ----------------------- ##

AT_INIT

AT_TESTED([bison])
